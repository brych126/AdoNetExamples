using Microsoft.Data.SqlClient;
using System.Data;

namespace AdoNetExamples
{
    public static class CommandBuilderCrudDemo
    {
        public static void RunAutoGeneratedCommands()
        {
            using var conn = new SqlConnection(AdoNetExamplesConnectionStringBuilder.ConnectionString);
            conn.StateChange += SqlConnectionEventsExamples.OnStateChange;
            conn.Open();

            //db command builder doesn't retrieve identity by default 
            // so reset identity to fill gaps
            //its not practical
            var resetIdentityCommand = new SqlCommand(@"
DECLARE @max_id INT;
SELECT @max_id = MAX(Id) FROM Customers;
DBCC CHECKIDENT ('Customers', RESEED, @max_id);
", conn);
            resetIdentityCommand.ExecuteNonQuery();

            // 1) Set up a DataAdapter with a PK-capable SELECT (must include the PK column)
            using var adapter = new SqlDataAdapter(
                "SELECT Id, [Name], Email, CreatedAt FROM dbo.Customers ORDER BY Id", conn);
            // Ensure the DataTable gets PK info (needed for UPDATE/DELETE)
            adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;

            // 2) Attach a CommandBuilder to auto-generate Insert/Update/Delete
            using var builder = new SqlCommandBuilder(adapter);

            //do not include all columns into update command condition
            builder.ConflictOption = ConflictOption.OverwriteChanges;
            // Optional: customize naming; otherwise the builder does it automatically
            builder.QuotePrefix = "[";
            builder.QuoteSuffix = "]";

            // 3) Fill a DataTable
            var table = new DataTable("Customers");
            adapter.Fill(table);

            Console.WriteLine("=== BEFORE ===");
            Dump(table);

            // -----------------------
            // INSERT
            // -----------------------
            Console.WriteLine("\n=== INSERT ===");
            var newRow = table.NewRow();
            newRow["Name"] = "Zoe";
            newRow["Email"] = "zoe@example.com";
            newRow["CreatedAt"] = DateTime.UtcNow;
            table.Rows.Add(newRow);

            var newRow2 = table.NewRow();
            newRow2["Name"] = "Zoe";
            newRow2["Email"] = "zoe2@example.com";
            newRow2["CreatedAt"] = DateTime.UtcNow;
            table.Rows.Add(newRow2);


            Console.WriteLine($"Insert command:\n{builder.GetInsertCommand().CommandText}");
            // Push changes to DB; CommandBuilder-generated INSERT will run
            // it pushes each statement in scope of separate round trip which is bad
            adapter.Update(table);

            // After Update, the builder’s INSERT typically returns SCOPE_IDENTITY()
            // and updates the DataRow’s Id in place.
            Console.WriteLine($"Inserted row got Id = {newRow["Id"]}");

            // -----------------------
            // UPDATE
            // -----------------------
            Console.WriteLine("\n=== UPDATE ===");
            newRow["Email"] = "zoe.updated@example.com";
            Console.WriteLine($"Update command:\n{builder.GetUpdateCommand().CommandText}");
            adapter.Update(table);
            Console.WriteLine("Row updated.");
            Dump(table);

            // -----------------------
            // DELETE
            // -----------------------
            Console.WriteLine("\n=== DELETE ===");
            newRow.Delete();          // marks row as Deleted
            Console.WriteLine($"Delete command:\n{builder.GetDeleteCommand().CommandText}");
            adapter.Update(table);    // runs auto-generated DELETE
            Console.WriteLine("Row deleted.");

            // Re-fetch to show final state
            table.Clear();
            adapter.Fill(table);

            Console.WriteLine("\n=== AFTER ===");
            Dump(table);

            CleanUp(conn);
        }

        public static void RunAutoGeneratedCommandsWithCustomRetrievingIdentityViaOutputInserted()
        {
            using var conn = new SqlConnection(AdoNetExamplesConnectionStringBuilder.ConnectionString);
            conn.StateChange += SqlConnectionEventsExamples.OnStateChange;
            conn.Open();

            using var adapter = new SqlDataAdapter(
                "SELECT Id, [Name], Email, CreatedAt FROM dbo.Customers ORDER BY Id", conn);

            adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;

            // Auto-gen UPDATE/DELETE
            using var cb = new SqlCommandBuilder(adapter);
            // If you want PK-only WHERE (avoid CreatedAt precision issues):
            cb.ConflictOption = ConflictOption.OverwriteChanges;

            // Custom INSERT that returns the inserted row values
            adapter.InsertCommand = new SqlCommand(@"
INSERT INTO dbo.Customers([Name], Email)
OUTPUT INSERTED.Id, INSERTED.[Name], INSERTED.Email, INSERTED.CreatedAt
VALUES (@Name, @Email);", conn);

            // Map input params
            adapter.InsertCommand.Parameters.Add("@Name", SqlDbType.NVarChar, 100, "Name");
            adapter.InsertCommand.Parameters.Add("@Email", SqlDbType.NVarChar, 255, "Email").IsNullable = true;

            // Instruct the adapter to apply the first returned row onto the DataRow

            //Default is both
            adapter.InsertCommand.UpdatedRowSource = UpdateRowSource.FirstReturnedRecord;

            // Now do the usual DataTable work
            var table = new DataTable();
            adapter.Fill(table);

            var r = table.NewRow();
            r["Name"] = "Zoe";
            r["Email"] = "zoe@example.com";
            r["CreatedAt"] = DateTime.MinValue;
            table.Rows.Add(r);

            // This will populate r["Id"] and r["CreatedAt"] from OUTPUT INSERTED...
            adapter.Update(table);
            Console.WriteLine($"Inserted row got Id = {r["Id"]} and CreatedAt = {r["CreatedAt"]}");

            // UPDATE & DELETE will now match by the real Id
            r["Email"] = "new_zoe.updated@example.com";
            adapter.Update(table);

            r.Delete();
            adapter.Update(table);
            CleanUp(conn);
        }

        public static void RunAutoGeneratedCommandsWithCustomRetrievingIdentityViaScopeIdentity()
        {
            using var conn = new SqlConnection(AdoNetExamplesConnectionStringBuilder.ConnectionString);
            conn.StateChange += SqlConnectionEventsExamples.OnStateChange;
            conn.Open();

            using var adapter = new SqlDataAdapter(
                "SELECT Id, [Name], Email, CreatedAt FROM dbo.Customers ORDER BY Id", conn);

            adapter.InsertCommand = new SqlCommand(@"
INSERT INTO dbo.Customers([Name], Email) VALUES (@Name, @Email);
SET @Id = CAST(SCOPE_IDENTITY() AS int);", conn);

            // input params
            adapter.InsertCommand.Parameters.Add("@Name", SqlDbType.NVarChar, 100, "Name");
            adapter.InsertCommand.Parameters.Add("@Email", SqlDbType.NVarChar, 255, "Email").IsNullable = true;

            // OUTPUT param mapped back to the Id column
            var pId = adapter.InsertCommand.Parameters.Add("@Id", SqlDbType.Int, 0, "Id");
            pId.Direction = ParameterDirection.Output;

            // Tell the adapter to apply OUTPUT params to the DataRow
            adapter.InsertCommand.UpdatedRowSource = UpdateRowSource.OutputParameters;

            var table = new DataTable();
            adapter.Fill(table);

            var r = table.NewRow();
            r["Name"] = "Zoe";
            r["Email"] = "zoe@example.com";
            r["CreatedAt"] = DateTime.MinValue;
            table.Rows.Add(r);

            // This will populate r["Id"] and r["CreatedAt"] from OUTPUT INSERTED...
            adapter.Update(table);
            Console.WriteLine($"Inserted row got Id = {r["Id"]} and CreatedAt = {r["CreatedAt"]}");

            CleanUp(conn);
        }

        private static void CleanUp(SqlConnection connection)
        {
            var affectedRows = new SqlCommand(@"
DELETE Customers
WHERE [Name] = 'Zoe'",
                connection).ExecuteNonQuery();

            Console.WriteLine($"\nClearing is finished. Deleted rows number: {affectedRows}");
        }

        private static void Dump(DataTable dt)
        {
            foreach (DataRow r in dt.Rows)
            {
                Console.WriteLine($"{r["Id"],3} | {r["Name"],-20} | {r["Email"],-30} | {r["CreatedAt"]}");
            }
        }
    }
}
