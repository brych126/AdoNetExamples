using Microsoft.Data.SqlClient;
using System.Data;
using System.Data.Common;

namespace AdoNetExamples
{
    /// <summary>
    /// Provides command builder examples
    /// See as well https://learn.microsoft.com/en-us/sql/connect/ado-net/update-data-sources-with-dataadapters?view=sql-server-ver17
    /// </summary>
    public static class CommandBuilderCrudDemo
    {
        public static void RunAutoGeneratedCommands()
        {
            using var conn = new SqlConnection(AdoNetExamplesConnectionStringBuilder.ConnectionString);
            conn.StateChange += SqlConnectionEventsExamples.OnStateChange;
            conn.Open();

            //db command builder doesn't retrieve identity by default 
            // so reset identity to fill gaps
            //its not practical
            var resetIdentityCommand = new SqlCommand(@"
DECLARE @max_id INT;
SELECT @max_id = MAX(Id) FROM Customers;
DBCC CHECKIDENT ('Customers', RESEED, @max_id);
", conn);
            resetIdentityCommand.ExecuteNonQuery();

            // 1) Set up a DataAdapter with a PK-capable SELECT (must include the PK column)
            using var adapter = new SqlDataAdapter(
                "SELECT Id, [Name], Email, CreatedAt FROM dbo.Customers ORDER BY Id", conn);
            // Ensure the DataTable gets PK info (needed for UPDATE/DELETE)
            adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;

            // 2) Attach a CommandBuilder to auto-generate Insert/Update/Delete
            using var builder = new SqlCommandBuilder(adapter);

            //do not include all columns into update command condition
            builder.ConflictOption = ConflictOption.OverwriteChanges;
            // Optional: customize naming; otherwise the builder does it automatically
            builder.QuotePrefix = "[";
            builder.QuoteSuffix = "]";

            // 3) Fill a DataTable
            var table = new DataTable("Customers");
            adapter.Fill(table);

            Console.WriteLine("=== BEFORE ===");
            Dump(table);

            // -----------------------
            // INSERT
            // -----------------------
            Console.WriteLine("\n=== INSERT ===");
            var newRow = table.NewRow();
            newRow["Name"] = "Zoe";
            newRow["Email"] = "zoe@example.com";
            newRow["CreatedAt"] = DateTime.UtcNow;
            table.Rows.Add(newRow);

            var newRow2 = table.NewRow();
            newRow2["Name"] = "Zoe";
            newRow2["Email"] = "zoe2@example.com";
            newRow2["CreatedAt"] = DateTime.UtcNow;
            table.Rows.Add(newRow2);


            Console.WriteLine($"Insert command:\n{builder.GetInsertCommand().CommandText}");
            // Push changes to DB; CommandBuilder-generated INSERT will run
            // it pushes each statement in scope of separate round trip which is bad
            adapter.Update(table);

            Console.WriteLine($"Inserted row got Id = {newRow["Id"]}");

            // -----------------------
            // UPDATE
            // -----------------------
            Console.WriteLine("\n=== UPDATE ===");
            newRow["Email"] = "zoe.updated@example.com";
            Console.WriteLine($"Update command:\n{builder.GetUpdateCommand().CommandText}");
            adapter.Update(table);
            Console.WriteLine("Row updated.");
            Dump(table);

            // -----------------------
            // DELETE
            // -----------------------
            Console.WriteLine("\n=== DELETE ===");
            newRow.Delete();          // marks row as Deleted
            Console.WriteLine($"Delete command:\n{builder.GetDeleteCommand().CommandText}");
            adapter.Update(table);    // runs auto-generated DELETE
            Console.WriteLine("Row deleted.");

            // Re-fetch to show final state
            table.Clear();
            adapter.Fill(table);

            Console.WriteLine("\n=== AFTER ===");
            Dump(table);

            CleanUp(conn);
        }

        public static void RunAutoGeneratedCommandsWithCustomRetrievingIdentityViaOutputInserted()
        {
            using var conn = new SqlConnection(AdoNetExamplesConnectionStringBuilder.ConnectionString);
            conn.StateChange += SqlConnectionEventsExamples.OnStateChange;
            conn.Open();

            using var adapter = new SqlDataAdapter(
                "SELECT Id, [Name], Email, CreatedAt FROM dbo.Customers ORDER BY Id", conn);

            adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;

            // Auto-gen UPDATE/DELETE
            using var cb = new SqlCommandBuilder(adapter);
            // If you want PK-only WHERE (avoid CreatedAt precision issues):
            cb.ConflictOption = ConflictOption.OverwriteChanges;

            // Custom INSERT that returns the inserted row values
            adapter.InsertCommand = new SqlCommand(@"
INSERT INTO dbo.Customers([Name], Email)
OUTPUT INSERTED.Id, INSERTED.[Name], INSERTED.Email, INSERTED.CreatedAt
VALUES (@Name, @Email);", conn);

            // Map input params
            adapter.InsertCommand.Parameters.Add("@Name", SqlDbType.NVarChar, 100, "Name");
            adapter.InsertCommand.Parameters.Add("@Email", SqlDbType.NVarChar, 255, "Email").IsNullable = true;

            // Instruct the adapter to apply the first returned row onto the DataRow

            //Default is both
            adapter.InsertCommand.UpdatedRowSource = UpdateRowSource.FirstReturnedRecord;

            // Now do the usual DataTable work
            var table = new DataTable();
            adapter.Fill(table);

            var r = table.NewRow();
            r["Name"] = "Zoe";
            r["Email"] = "zoe@example.com";
            r["CreatedAt"] = DateTime.MinValue;
            table.Rows.Add(r);

            // This will populate r["Id"] and r["CreatedAt"] from OUTPUT INSERTED...
            adapter.Update(table);
            Console.WriteLine($"Inserted row got Id = {r["Id"]} and CreatedAt = {r["CreatedAt"]}");

            // UPDATE & DELETE will now match by the real Id
            r["Email"] = "new_zoe.updated@example.com";
            adapter.Update(table);

            r.Delete();
            adapter.Update(table);
            CleanUp(conn);
        }

        public static void RunAutoGeneratedCommandsWithCustomRetrievingIdentityViaScopeIdentity()
        {
            using var conn = new SqlConnection(AdoNetExamplesConnectionStringBuilder.ConnectionString);
            conn.StateChange += SqlConnectionEventsExamples.OnStateChange;
            conn.Open();

            using var adapter = new SqlDataAdapter(
                "SELECT Id, [Name], Email, CreatedAt FROM dbo.Customers ORDER BY Id", conn);
            adapter.UpdateBatchSize = 5;

            adapter.InsertCommand = new SqlCommand(@"
INSERT INTO dbo.Customers([Name], Email) VALUES (@Name, @Email);
SET @Id = CAST(SCOPE_IDENTITY() AS int);", conn);

            // input params
            adapter.InsertCommand.Parameters.Add("@Name", SqlDbType.NVarChar, 100, "Name");
            adapter.InsertCommand.Parameters.Add("@Email", SqlDbType.NVarChar, 255, "Email").IsNullable = true;

            // OUTPUT param mapped back to the Id column
            var pId = adapter.InsertCommand.Parameters.Add("@Id", SqlDbType.Int, 0, "Id");
            pId.Direction = ParameterDirection.Output;

            // Tell the adapter to apply OUTPUT params to the DataRow
            adapter.InsertCommand.UpdatedRowSource = UpdateRowSource.OutputParameters;

            var table = new DataTable();
            adapter.Fill(table);

            var r1 = table.NewRow();
            r1["Name"] = "Zoe";
            r1["Email"] = "zoe1@example.com";
            r1["CreatedAt"] = DateTime.MinValue;
            table.Rows.Add(r1);

            var r2 = table.NewRow();
            r2["Name"] = "Zoe";
            r2["Email"] = "zoe2@example.com";
            r2["CreatedAt"] = DateTime.MinValue;
            table.Rows.Add(r2);

            // This will populate r["Id"] and r["CreatedAt"] from passed output param
            adapter.Update(table);
            Console.WriteLine($"Inserted row1 got Id = {r1["Id"]}");
            Console.WriteLine($"Inserted row2 got Id = {r2["Id"]}");

            CleanUp(conn);
        }


        #region MySchool
        public static void MySchoolDbAdapterUpdate()
        {
            using SqlConnection connection =
                new SqlConnection(MySchoolDbConnectionStringBuilder.ConnectionString);
            SqlDataAdapter dataAdpater = new SqlDataAdapter(
                "Select DepartmentID, [Name] from Department;",
                connection);

            dataAdpater.UpdateCommand = new SqlCommand(
                "UPDATE Department SET [Name] = @DepartmentName " +
                "WHERE [Name] = @OldDepartmentName", connection);

            dataAdpater.UpdateCommand.Parameters.Add(
                "@DepartmentName", SqlDbType.NVarChar, 50, "DepartmentName");

            SqlParameter parameter = dataAdpater.UpdateCommand.Parameters.Add(
                "@OldDepartmentName", SqlDbType.NVarChar, 50);
            parameter.SourceColumn = "DepartmentName";
            parameter.SourceVersion = DataRowVersion.Original;

            DataSet ds = new DataSet();
            DataTableMapping mapping =
                dataAdpater.TableMappings.Add("Table", "Department");
            mapping.ColumnMappings.Add("Name", "DepartmentName");
            dataAdpater.Fill(ds);
            DataTable departmentTable = ds.Tables[0];

            DataRow departmentTableRow = departmentTable.Rows[0];
            UpdateDepartmentName(departmentTableRow, "Software Engineering");
            UpdateDepartmentName(departmentTableRow, "Advanced Software Engineering");

            void UpdateDepartmentName(DataRow rowToUpdate, string newName)
            {

                rowToUpdate["DepartmentName"] = newName;

                Console.WriteLine("Rows before update.");
                foreach (DataRow row in departmentTable.Rows)
                {
                    Console.WriteLine("{0}: {1} : {2}", row[0], row[1, DataRowVersion.Original],
                        row[1, DataRowVersion.Current]);
                }

                dataAdpater.Update(departmentTable);

                Console.WriteLine("Rows after update.");
                foreach (DataRow row in departmentTable.Rows)
                {
                    Console.WriteLine("{0}: {1} : {2}", row[0], row[1, DataRowVersion.Original],
                        row[1, DataRowVersion.Current]);
                }
            }
        }

        public static void MySchoolDbExample()
        {

            // Copy the data from the database.  Get the table Department and Course from the database.
            String selectString = @"SELECT [DepartmentID],[Name],[Budget],[StartDate],[Administrator]
                                     FROM [MySchool].[dbo].[Department];

                                   SELECT [CourseID],@Year as [Year],Max([Title]) as [Title],
                                   Max([Credits]) as [Credits],Max([DepartmentID]) as [DepartmentID]
                                   FROM [MySchool].[dbo].[Course]
                                   Group by [CourseID]";

            DataSet mySchool = new DataSet();

            SqlCommand selectCommand = new SqlCommand(selectString);
            SqlParameter parameter = selectCommand.Parameters.Add("@Year", SqlDbType.SmallInt, 2);
            parameter.Value = new Random(DateTime.Now.Millisecond).Next(9999);

            // Use DataTableMapping to map the source tables and the destination tables.
            DataTableMapping[] tableMappings = [new("Table", "Department"), new("Table1", "Course")];
            CopyData(mySchool, MySchoolDbConnectionStringBuilder.ConnectionString, selectCommand, tableMappings);

            Console.WriteLine("The following tables are from the database.");
            foreach (DataTable table in mySchool.Tables)
            {
                Console.WriteLine(table.TableName);
                ShowDataTable(table);
            }

            // Roll back the changes
            DataTable department = mySchool.Tables["Department"]!;
            DataTable course = mySchool!.Tables["Course"]!;

            department.Rows[0]["Name"] = "New" + department.Rows[0][1];
            course!.Rows[0]["Title"] = "New" + course.Rows[0]["Title"];
            course.Rows[0]["Credits"] = 10;

            Console.WriteLine("After we changed the tables:");
            foreach (DataTable table in mySchool.Tables)
            {
                Console.WriteLine(table.TableName);
                ShowDataTable(table);
            }

            department.RejectChanges();
            Console.WriteLine("After use the RejectChanges method in Department table to roll back the changes:");
            ShowDataTable(department);

            DataColumn[] primaryColumns = [course!.Columns["CourseID"]!];
            DataColumn[] resetColumns = [course!.Columns["Title"]!];
            ResetCourse(course, MySchoolDbConnectionStringBuilder.ConnectionString, primaryColumns, resetColumns);
            Console.WriteLine("After use the ResetCourse method in Course table to roll back the changes:");
            ShowDataTable(course);

            // Batch update the table.
            String insertString = @"Insert into [MySchool].[dbo].[Course]([CourseID],[Year],[Title],
                                   [Credits],[DepartmentID])
             values (@CourseID,@Year,@Title,@Credits,@DepartmentID)";
            SqlCommand insertCommand = new SqlCommand(insertString);
            insertCommand.Parameters.Add("@CourseID", SqlDbType.NVarChar, 10, "CourseID");
            insertCommand.Parameters.Add("@Year", SqlDbType.SmallInt, 2, "Year");
            insertCommand.Parameters.Add("@Title", SqlDbType.NVarChar, 100, "Title");
            insertCommand.Parameters.Add("@Credits", SqlDbType.Int, 4, "Credits");
            insertCommand.Parameters.Add("@DepartmentID", SqlDbType.Int, 4, "DepartmentID");

            const Int32 batchSize = 10;
            BatchInsertUpdate(course, MySchoolDbConnectionStringBuilder.ConnectionString, insertCommand, batchSize);
        }

        private static void CopyData(DataSet dataSet, String connectionString, SqlCommand selectCommand, DataTableMapping[] tableMappings)
        {
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                selectCommand.Connection = connection;

                connection.Open();

                using (SqlDataAdapter adapter = new SqlDataAdapter(selectCommand))
                {
                    adapter.TableMappings.AddRange(tableMappings);
                    // If set the AcceptChangesDuringFill as the false, AcceptChanges will not be called on a
                    // DataRow after it is added to the DataTable during any of the Fill operations.
                    adapter.AcceptChangesDuringFill = false;

                    adapter.Fill(dataSet);
                }
            }
        }

        // Roll back only one column or several columns data of the Course table by call ResetDataTable method.
        private static void ResetCourse(DataTable table, String connectionString,
            DataColumn[] primaryColumns, DataColumn[] resetColumns)
        {
            table.PrimaryKey = primaryColumns;

            // Build the query string
            String primaryCols = String.Join(",", primaryColumns.Select(col => col.ColumnName));
            String resetCols = String.Join(",", resetColumns.Select(col => $"Max({col.ColumnName}) as {col.ColumnName}"));

            String selectString = $"Select {primaryCols},{resetCols} from Course Group by {primaryCols}";

            SqlCommand selectCommand = new SqlCommand(selectString);

            ResetDataTable(table, connectionString, selectCommand);
        }

        // RejectChanges will roll back all changes made to the table since it was loaded, or the last time AcceptChanges
        // was called. When you copy from the database, you can lose all the data after calling RejectChanges
        // The ResetDataTable method rolls back one or more columns of data.
        private static void ResetDataTable(DataTable table, String connectionString,
            SqlCommand selectCommand)
        {
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                selectCommand.Connection = connection;

                connection.Open();

                using (SqlDataAdapter adapter = new SqlDataAdapter(selectCommand))
                {
                    // The incoming values for this row will be written to the current version of each
                    // column. The original version of each column's data will not be changed.
                    adapter.FillLoadOption = LoadOption.Upsert;

                    adapter.Fill(table);
                }
            }
        }

        private static void BatchInsertUpdate(DataTable table, String connectionString,
            SqlCommand insertCommand, Int32 batchSize)
        {
            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                insertCommand.Connection = connection;
                // When setting UpdateBatchSize to a value other than 1, all the commands
                // associated with the SqlDataAdapter have to have their UpdatedRowSource
                // property set to None or OutputParameters. An exception is thrown otherwise.
                insertCommand.UpdatedRowSource = UpdateRowSource.None;

                connection.Open();

                using (SqlDataAdapter adapter = new SqlDataAdapter())
                {
                    adapter.InsertCommand = insertCommand;
                    // Gets or sets the number of rows that are processed in each round-trip to the server.
                    // Setting it to 1 disables batch updates, as rows are sent one at a time.
                    adapter.UpdateBatchSize = batchSize;

                    adapter.Update(table);

                    Console.WriteLine("Successfully to update the table.");
                }
            }
        }

        private static void ShowDataTable(DataTable table)
        {
            foreach (DataColumn col in table.Columns)
            {
                Console.Write("{0,-14}", col.ColumnName);
            }
            Console.WriteLine("{0,-14}", "RowState");

            foreach (DataRow row in table.Rows)
            {
                foreach (DataColumn col in table.Columns)
                {
                    if (col.DataType.Equals(typeof(DateTime)))
                        Console.Write("{0,-14:d}", row[col]);
                    else if (col.DataType.Equals(typeof(Decimal)))
                        Console.Write("{0,-14:C}", row[col]);
                    else
                        Console.Write("{0,-14}", row[col]);
                }
                Console.WriteLine("{0,-14}", row.RowState);
            }
        }

        #endregion


        private static void CleanUp(SqlConnection connection)
        {
            var affectedRows = new SqlCommand(@"
DELETE Customers
WHERE [Name] = 'Zoe'",
                connection).ExecuteNonQuery();

            Console.WriteLine($"\nClearing is finished. Deleted rows number: {affectedRows}");
        }

        private static void Dump(DataTable dt)
        {
            foreach (DataRow r in dt.Rows)
            {
                Console.WriteLine($"{r["Id"],3} | {r["Name"],-20} | {r["Email"],-30} | {r["CreatedAt"]}");
            }
        }
    }
}
