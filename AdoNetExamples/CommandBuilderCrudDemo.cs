using Microsoft.Data.SqlClient;
using System.Data;

namespace AdoNetExamples
{
    public static class CommandBuilderCrudDemo
    {
        public static void RunAutoGeneratedCommands()
        {
            using var conn = new SqlConnection(AdoNetExamplesConnectionStringBuilder.ConnectionString);
            conn.Open();

            //db command builder doesn't retrieve identity by default 
            // so it is needed to fill gaps
            var resetIdentityCommand = new SqlCommand(@"
DECLARE @max_id INT;
SELECT @max_id = MAX(Id) FROM Customers;
DBCC CHECKIDENT ('Customers', RESEED, @max_id);
", conn);
            resetIdentityCommand.ExecuteNonQuery();

            // 1) Set up a DataAdapter with a PK-capable SELECT (must include the PK column)
            using var adapter = new SqlDataAdapter(
                "SELECT Id, [Name], Email, CreatedAt FROM dbo.Customers ORDER BY Id", conn);
            // Ensure the DataTable gets PK info (needed for UPDATE/DELETE)
            adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;

            // 2) Attach a CommandBuilder to auto-generate Insert/Update/Delete
            using var builder = new SqlCommandBuilder(adapter);

            //do not include all columns into update command condition
            builder.ConflictOption = ConflictOption.OverwriteChanges;
            // Optional: customize naming; otherwise the builder does it automatically
            builder.QuotePrefix = "[";
            builder.QuoteSuffix = "]";

            // 3) Fill a DataTable
            var table = new DataTable("Customers");
            adapter.Fill(table);

            Console.WriteLine("=== BEFORE ===");
            Dump(table);

            // -----------------------
            // INSERT
            // -----------------------
            Console.WriteLine("\n=== INSERT ===");
            var newRow = table.NewRow();
            newRow["Name"] = "Zoe";
            newRow["Email"] = "zoe@example.com";
            newRow["CreatedAt"] = DateTime.UtcNow;
            table.Rows.Add(newRow);

            var newRow2 = table.NewRow();
            newRow2["Name"] = "Zoe";
            newRow2["Email"] = "zoe2@example.com";
            newRow2["CreatedAt"] = DateTime.UtcNow;
            table.Rows.Add(newRow2);


            Console.WriteLine($"Insert command:\n{builder.GetInsertCommand().CommandText}");
            // Push changes to DB; CommandBuilder-generated INSERT will run
            // it pushes each statement in scope of separate round trip which is bad
            adapter.Update(table);

            // After Update, the builder’s INSERT typically returns SCOPE_IDENTITY()
            // and updates the DataRow’s Id in place.
            Console.WriteLine($"Inserted row got Id = {newRow["Id"]}");

            // -----------------------
            // UPDATE
            // -----------------------
            Console.WriteLine("\n=== UPDATE ===");
            newRow["Email"] = "zoe.updated@example.com";
            Console.WriteLine($"Update command:\n{builder.GetUpdateCommand().CommandText}");
            adapter.Update(table);
            Console.WriteLine("Row updated.");
            Dump(table);

            // -----------------------
            // DELETE
            // -----------------------
            Console.WriteLine("\n=== DELETE ===");
            newRow.Delete();          // marks row as Deleted
            Console.WriteLine($"Delete command:\n{builder.GetDeleteCommand().CommandText}");
            adapter.Update(table);    // runs auto-generated DELETE
            Console.WriteLine("Row deleted.");

            // Re-fetch to show final state
            table.Clear();
            adapter.Fill(table);

            Console.WriteLine("\n=== AFTER ===");
            Dump(table);
        }

        private static void Dump(DataTable dt)
        {
            foreach (DataRow r in dt.Rows)
            {
                Console.WriteLine($"{r["Id"],3} | {r["Name"],-20} | {r["Email"],-30} | {r["CreatedAt"]}");
            }
        }
    }
}
